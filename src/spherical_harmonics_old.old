package game

import "core:fmt"
import "core:math"
import "core:time"
import vk "vendor:vulkan"

import vma "deps:odin-vma"

import "gfx"

ShCoefficients :: [9][3]f32

SHCubeMapPushConstants :: struct {
	sh: gfx.GPUPointer(ShCoefficients),
}

SHCubeMapPass :: struct {
	descriptor_set_layout: vk.DescriptorSetLayout,
	descriptor_set:        vk.DescriptorSet,
	pipeline:              vk.Pipeline,
	pipeline_layout:       vk.PipelineLayout,

	// Resources
	cube_image:            gfx.GPUImage,
	cube_sampler:          vk.Sampler,
	sh_mapped_buffer:      gfx.GPUBuffer,
	width:                 u32,
	height:                u32,
}

create_spherical_harmonicsed_cubemap_pipeline :: proc(filename: cstring) -> SHCubeMapPass {
	pass := SHCubeMapPass {}

	pass.descriptor_set_layout = gfx.create_descriptor_set_layout(
		{
			{binding = 0, type = .COMBINED_IMAGE_SAMPLER},
		},
		{.UPDATE_AFTER_BIND_POOL},
		{.COMPUTE},
	)

	gfx.defer_destroy(&gfx.renderer().global_arena, pass.descriptor_set_layout)

	pass.descriptor_set = gfx.allocate_descriptor_set(
		&gfx.renderer().global_descriptor_allocator,
		gfx.renderer().device,
		pass.descriptor_set_layout,
	)

	pass.cube_image = gfx.load_image_from_file(filename, .D2, .CUBE, &pass.width, &pass.height)
	pass.cube_sampler = gfx.create_sampler(.NEAREST, .CLAMP_TO_EDGE)

	// Maybe we can make a nicer abstraction?
	gfx.write_descriptor_set(
		pass.descriptor_set,
		{
			{
				binding      = 0,
				type         = .COMBINED_IMAGE_SAMPLER, // We know this
				image_view   = pass.cube_image.image_view,
				sampler      = pass.cube_sampler,
				image_layout = .SHADER_READ_ONLY_OPTIMAL,
			},
		},
	)

	spherical_harmonics_shader, f_ok := gfx.load_shader_module("shaders/out/spherical_harmonics.spv")
	assert(f_ok, "Failed to load shaders.")

	pass.pipeline_layout = gfx.create_pipeline_layout_pc(&pass.descriptor_set_layout, SHCubeMapPushConstants, {.COMPUTE})
	pass.pipeline = gfx.create_compute_pipelines(pass.pipeline_layout, spherical_harmonics_shader)

	gfx.destroy_shader_module(spherical_harmonics_shader)

	gfx.defer_destroy(&gfx.renderer().global_arena, pass.pipeline)
	gfx.defer_destroy(&gfx.renderer().global_arena, pass.pipeline_layout)

	pass.sh_mapped_buffer = gfx.create_buffer(vk.DeviceSize(size_of(ShCoefficients)), {.TRANSFER_DST, .SHADER_DEVICE_ADDRESS}, .GPU_TO_CPU)

	return pass
}

run_spherical_harmonics_cubemap_pass :: proc(pass: ^SHCubeMapPass, cmd: vk.CommandBuffer) {
	vk.CmdBindPipeline(cmd, .COMPUTE, pass.pipeline)
	vk.CmdBindDescriptorSets(cmd, .COMPUTE, pass.pipeline_layout, 0, 1, &pass.descriptor_set, 0, nil)

	constants: SHCubeMapPushConstants
	constants.sh.a = gfx.get_buffer_device_address(pass.sh_mapped_buffer)

	vk.CmdPushConstants(cmd, pass.pipeline_layout, {.COMPUTE}, 0, size_of(SHCubeMapPushConstants), &constants)
	vk.CmdDispatch(cmd, 1, 1, 1) // Currently not parallelized (not really sure how that works with BDA...)
}
